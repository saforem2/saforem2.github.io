---
jupyter: brew-py311
sidebar: false
title: "Loooooooong Sequence Lengths"
callout-appearance: simple
title-block-banner: false
# https://www.anl.gov/sites/www/files/2021-09/CPA_RESIZE_Climate%20Resilience%20Images_01_1920x1080.jpg
editor:
   render-on-save: true
execute:
   freeze: true
---

<!-- <img align="left" width="48%"  src="https://raw.githubusercontent.com/saforem2/scaling4science/main/assets/25B.svg"> <img align="right" width="48%" src="https://raw.githubusercontent.com/saforem2/scaling4science/main/assets/33B.svg"> -->

## Initial Results

::: {.callout-important title="PRE-RELEASE" collapse="false" style="width: 100%;"}

I've kept in the (executable) code blocks for the time being (just to show how
I'm generating the bar plots in [@fig-seq-len]) but these can be ommitted in
the actual README

:::



```{python}
import os
import numpy as np
import datetime
from typing import Tuple
import matplotlib.pyplot as plt
from pathlib import Path
# toolbox comes from
# https://github.com/saforem2/toolbox
from toolbox import set_plot_style
import seaborn as sns

sns.set_context('talk')
set_plot_style()

def save_figure(
        fname: str,
        outdir: os.PathLike,
):
    pngdir = Path(outdir).joinpath('pngs')
    svgdir = Path(outdir).joinpath('svgs')
    pngdir.mkdir(exist_ok=True, parents=True)
    svgdir.mkdir(exist_ok=True, parents=True)
    pngfile = pngdir.joinpath(f'{fname}.png')
    svgfile = svgdir.joinpath(f'{fname}.svg')
    _ = plt.savefig(pngfile, dpi=400, bbox_inches='tight')
    _ = plt.savefig(svgfile, dpi=400, bbox_inches='tight')
```

```{python}
gpus = ('32', '64', '128')

data = {
    '25B': {
        'Old': (28, 32, 32),
        'Nvidia': (14, 46, 52),
        'New': (128, 384, 448),
    },
    '33B': {
        'Old': (36, 42, 42),
        'Nvidia': (26, 48, 52),
        'New': (192, 448, 512),
    }
}
```

::: {#fig-seq-len}

```{python}
#| layout-ncol: 2
#| fig-cap:
#|   - "`25B` Model"
#|   - "`33B` Model"
x = np.arange(len(gpus))
width = 0.25
multiplier = 0

outdir = Path(os.getcwd()).joinpath('assets')
outdir.mkdir(exist_ok=True, parents=True)

from toolbox import COLORS
colors = {
    'Old': COLORS['red'],
    'Nvidia': COLORS['green'],
    'New': COLORS['blue']
}
for model_size, d in data.items():
    multiplier = 0
    figure, axes = plt.subplots(layout='constrained')
    fig = plt.gcf()
    ax = plt.gca()
    for label, value in d.items():
        offset = width * multiplier
        rects = ax.bar(x + offset, value, width, label=label, color=colors[label])
        ax.bar_label(rects, padding=3)
        multiplier += 1
    ax.set_ylabel('Sequence Length (k)', fontsize='large')
    ax.set_xlabel('GPUs', fontsize='large')
    ax.set_title(f'{model_size} Model', fontsize='large')
    ax.set_xticks(x + width, gpus)
    ax.legend(loc='best', ncols=1, frameon=True)
    save_figure(fname=f'{model_size}', outdir=outdir)
    _ = plt.show()
```

Maximum Sequence Lengths Achievable across different implementations, model
sizes and GPUs.  
In each case, the `new` (current) implementation **significantly** outperforms
both NVIDIA/Megatron-LM as well as our previous implementation.
:::

::: {#fig-table}

```{python}
import pandas as pd
from toolbox import get_console
console = get_console()
df = pd.read_csv('./data.csv')
df
# pd.DataFrame(data)
# console.print(df)
```

Maximum Sequence Length Results
:::


## New Results

<iframe src="https://wandb.ai/l2hmc-qcd/Megatron-DS-Benchmarking/reports/Looooooong-Sequences--Vmlldzo1MzI2NjA1" style="border:none;height:1024px;width:100%">

</iframe>
